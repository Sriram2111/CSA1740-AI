from collections import deque

# Define the goal state
goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

# Define possible moves (right, down, left, up)
moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]

def is_goal(state):
    return state == goal_state

def get_blank_pos(state):
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j

def valid_pos(x, y):
    return 0 <= x < 3 and 0 <= y < 3

def get_neighbors(state):
    neighbors = []
    x, y = get_blank_pos(state)
    
    for dx, dy in moves:
        nx, ny = x + dx, y + dy
        if valid_pos(nx, ny):
            new_state = [row[:] for row in state]
            new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]
            neighbors.append(new_state)
    
    return neighbors

def solve_puzzle(initial_state):
    queue = deque([(initial_state, [])])
    visited = set()
    
    while queue:
        state, path = queue.popleft()

        if is_goal(state):
            return path + [state]

        visited.add(tuple(map(tuple, state)))

        for neighbor in get_neighbors(state):
            neighbor_tuple = tuple(map(tuple, neighbor))
            if neighbor_tuple not in visited:
                queue.append((neighbor, path + [state]))

    return None

# Example usage
initial_state = [[1, 2, 3], [4, 5, 6], [7, 0, 8]]
solution_path = solve_puzzle(initial_state)

if solution_path:
    print("Solution found in", len(solution_path) - 1, "moves:")
    for step in solution_path:
        for row in step:
            print(row)
        print()
else:
    print("No solution found.")
